<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../paper-styles/paper-styles.html">

<dom-module id="exmg-date-format">
  <template>
    <style>
      :host {
        display: block;
      }

    </style>



  </template>

  <script>
  'use strict';
  {
    class DateElementElement extends Polymer.Element {
      static get is() {
        return 'exmg-date-format';
      }

      /**
      * Fired when an item is selected
      *
      * @event iron-select
      */

      /**
      * Fired when an item is deselected
      *
      * @event iron-deselect
      */

      static get properties() {
        return {
          /**
           * If you want to use an attribute value or property of an element for
           * `selected` instead of the index, set this to the name of the attribute
           * or property. Hyphenated values are converted to camel case when used to
           * look up the property of a selectable element. Camel cased values are
           * *not* converted to hyphenated values for attribute lookup. It's
           * recommended that you provide the hyphenated form of the name so that
           * selection works in both cases. (Use `attr-or-property-name` instead of
           * `attrOrPropertyName`.)
           */
          attrForSelected: {
            type: String,
            value: null
          },

          /**
           * By default the textContent of the paper-item/paper-icon-item or paper-item-body
           * will be used for display in badge after selection. In case of icon and body
           * you probably want an alternative. The selector can be used to be a bit more
           * specific on which element can be used for display purposes.
           */
          selectedItemSelector: {
            type: String,
            value: null
          },

          /**
          * Returns an array of currently selected items.
          */
          selectedItems: {
            type: Array,
            notify: true,
          },

          /**
          * Gets or sets the selected elements.
          */
          selectedValues: {
            type: Array,
            notify: true,
          },
          /**
          * The label for this input.
          */
          label: String,

          /**
           * Set to true to auto-validate the input value.
           */
          autoValidate: {
            type: Boolean,
            value: false
          },

          autofocus: {
            type: Boolean
          },

          /**
          * Set to true to disable this input.
          */
          disabled: {
            type: Boolean,
            value: false
          },

          /**
          * The error message to display when the input is invalid.
          */
          errorMessage: {
            type: String
          },

          /**
          * alwaysFloatLabel
          */
          alwaysFloatLabel: {
            type: Boolean,
            value: false
          },

          /**
          * Maximum number of tokens allowed in value
          */
          maxTokens: {
            type: Number
          },

          /**
           * Set to true to mark the input as required. If you're using PaperInputBehavior to
           * implement your own paper-input-like element, bind this to
           * the `<input is="iron-input">`'s `required` property.
           */
          required: {
            type: Boolean,
            value: false
          },

          /**
          * This field will be bind to the actual input field
          */
          _inputValue: {
            type: String,
          },

          _tokens: {
            type: Array,
            value: () => [],
          },

          invalid: {
            type: Boolean,
          },

          inputFocused: {
            type: Boolean,
          }
        };
      }
      static get observers() {
        return [
          '_observeInputChange(_inputValue)',
          '_observeSelectedItems(selectedItems.*)',
        ];
      }
      constructor() {
        super();
        this._boundKeyDown = this._handleKeyDown.bind(this);
        this._boundOutsideClick = this._handleClick.bind(this);
      }

      /**
       * Returns the index of the given item.
       *
       * @method indexOf
       * @param {Object} item
       * @returns Returns the index of the item
       */
      indexOf(item) {
        return this.$.listbox.items ? this.$.listbox.items.indexOf(item) : -1;
      }
      _handleClick(e) {
        const inside = e.path.find((path) => path === this);
        // Detect outside element click for auto validate input
        if (this.autoValidate && !inside && this.previousInsideClick) {
          this.validate();
        }
        this.previousInsideClick = inside;
      }
      _observeSelectedItems(c) {
        this.set('_tokens', this.selectedItems.map((si) => {
          const id = this.attrForSelected ? si.getAttribute(this.attrForSelected) : this.indexOf(si);
          const text = this.selectedItemSelector ? si.querySelector(this.selectedItemSelector).textContent
            : si.textContent;
          return {id, text};
        }));
      }
      _observeInputChange() {
        this.$.inputValue.style.width = (this.$.inputWidthHelper.offsetWidth + 10) + 'px';
        this._filterItems();
      }
      _filterItems() {
        const items = this.querySelectorAll('paper-item');
        for (var i = 0; i < items.length; i++) {
          if (this._inputValue.length > 0 && items[i].textContent.indexOf(this._inputValue) === -1) {
            items[i].setAttribute('hidden', '');
          } else {
            items[i].removeAttribute('hidden');
          }
        }
      }
      connectedCallback() {
        super.connectedCallback();

      }
      disconnectCallback() {
        this.$.inputValue.removeEventListener('keydown', this._boundKeyDown);
        if (this.autoValidate) {
          window.removeEventListener('click', this._boundOutsideClick);
        }
      }
      _handleKeyDown(e) {

      }
      _hasSelectedItems() {
        return this.selectedValues && this.selectedValues.length > 0;
      }
      _handleDeleteToken(e) {
        const i = Array.from(this.selectedValues).map(v => String(v)).indexOf(String(e.model.token.id));
        this.splice('selectedValues', i, 1);
        this.focus();
      }
      /**
       * this method can be used to set the focus of the element
       *
       * @method indexOf
       */
      focus() {
        this.$.inputValue.focus();
      }

      /**
       * This method will automaticly set the label float.
       */
      _computeAlwaysFloatLabel(selectedItemsChanges, alwaysFloatLabel) {
        if (alwaysFloatLabel) {
          return true;
        }
        return !(selectedItemsChanges.base !== undefined && selectedItemsChanges.base.length === 0
          && this.$.inputValue !== document.activeElement);
      }

      _handleContainerTap(e) {
        this.opened = true;
        Polymer.RenderStatus.afterNextRender(this, _ => this.focus());
      }

      _handleAddToken(e) {
        if (this.maxTokens && this.selectedItems.length > this.maxTokens) {
          e.stopPropagation();
          this.splice('selectedValues', this.selectedValues.length - 1, 1);
        }
        this._resetInput();
      }

      _resetInput() {
        if (this.autoValidate) {
          this.validate();
        }
        this._inputValue = '';
        this.focus();
      }

      /**
      * Returns true if `value` is valid.
      * @return {boolean} True if the value is valid.
      */
      validate() {
        this.invalid = this.required && !this._hasSelectedItems();
        return !this.invalid;
      }
    }

    window.customElements.define(DateElementElement.is, DateElementElement);
    /**
     * @namespace Exmg
     */
    window.Exmg = window.Exmg || {};
    Exmg.DateElementElement = DateElementElement;
  }
  </script>
</dom-module>
